## Микросервисы 

Разбиваем приложение на несколько мини частей, мини программы, которые называются сервисами. Один сервис выполняет одну бизнес задачу.Получается конструктор, где каждый сервис - это отдельный блок. Падение одного сервиса может пройти относительно безболезненно для всего приложения. Каждый сервис имеет свой API по которому к нему можно будет обратиться, чтобы он сделал какую-нибудь задачу. Так сервисы могут общаться между собой делая HTTP или gRPC запросы. Такой способ называется синхронной коммуникации. Когда мы отправляем запрос и ждем что нам ответят с той стороны. 

Перед всеми сервисами обычно ставят API Gateway. Он нужен, чтобы пользователи делали запросы не на сами сервисы, а сначала на него, а он потом маршрутизировал их.  

Еще один вариант общения - это ассинхронная коммуникация, когда нам не нужно ждать ответа от сервиса. Тут сообщения шлются какому-то брокеру, типа RAbbitMQ или Kafka. Они попадают там в очередь, а затем принимаются сервисом, который вычитывает эту очередь и там уже выполняются нужные действия. При этом отправитель не ждет ответа, он идет работать дальше. 

Но как всегда есть и обратная сторона. Одних сложностей становится меньше, зато появляются другие. Так нам нужно теперь поднимать и настраивать каждый сервис отдельно, и связывать их друг с другом. Тут нужно подходить с умом к архитектуре. Особенно важно обращать внимание на консистентность таких данных - раз микросерсис обладает опеделенным набором данных в своей базе или схеме, то сделать join к другой таблице не получится - нужно собирать все по кусочкам как пазл уже на уровне логики приложения. К тому же здесь не обойтись без набора DevOps инструментов. Нам понадобится контейниризация, чтобы удобно, компактно и независимо разворачивать микросервисы. Стобы гибко управлять всем этим, хорошо бы уметь в оркестрацию. Чтобы удобно было deploy, стоит знать CI/CD pipe lines. Ну и в добавок настроить логирование и мониторинг, чтобы в случае чего быстро находить проблемные места.


## Автоматизация тестирования: программирование в QA

Почему так важно автоматизировать? Один раз ты можешь сделать что-то вручную, но если это нужно повторить в третий и десятый раз? Тут уже становится понятно, что нужно экономить свои силы, нервы и время. И вот тестирование - это одна из тех областей, где автоматизация сильно помогает.

Тестировщики проверяют новый функционал приложения, чтобы убедиться, что он работает так, как задумано. Также проверяют старый функционал, чтобы удостовериться, что новые полезные фичи не сломали ничего старого. Программы, создающие программы, - это и есть автоматизированное тестирование. Это процесс, когда разработчики пишут специальные программы или скрипты, называемые автотестами, чтобы указать компьютеру, какие действия нужно выполнить для проверки, что все работает правильно. При запуске они выполняют десятки или даже сотни различных сценариев взаимодействия с системой, а затем сообщают, какие прошли успешно, а какие - нет.

Что конкретно делают эти автотесты?

Можно, например, тестировать API - написать программу, которая будет отправлять запросы к серверу с разными параметрами и сверять ответы, полученные от сервера, с ожидаемыми результатами программы.

В общем, берем тесты, которые раньше выполняли вручную, например, заходим на страницу, нажимаем туда и сюда, и смотрим, что происходит. Теперь заставляем это делать бездушной машине, которая не жалуется и выполняет все намного быстрее. Такой вид тестирования называется end-to-end, когда мы полностью проходим путь пользователя от лица пользователя.

А как это работает? Давайте посмотрим на инструменты для автоматического тестирования. Начнем с Selenium. Это целая система инструментов, используемых для автоматизации браузеров. Нас интересует Selenium WebDriver - библиотека, позволяющая подключаться к браузеру и отправлять команды для выполнения различных действий, таких как нажатие на кнопку, заполнение поля и т. д. Полученные данные можно использовать как результат теста. Для этого нужно написать код, описывающий последовательность действий браузера и ожидаемый результат. Selenium поддерживает языки Java, Ruby, JavaScript и, конечно же, Python.

Популярными аналогами являются Puppeteer, Playwright, Cypress или Appium, которые выполняют аналогичные задачи, но для мобильных телефонов. Это хорошо работает с фреймворками, упрощающими работу с тестами, такими как Pytest для Python или JUnit для Java. В двух словах - это набор специальных функций для вашего языка программирования, которые позволяют легко и удобно писать и запускать тесты в приложениях.

Есть еще один вид тестирования - нагрузочное тестирование. Его суть заключается в оценке того, как система справляется с нагрузкой и не выходит из строя при внедрении в продакшн. Например, отправка на сервер огромного количества разных запросов одновременно, как если бы это были реальные пользователи в черную пятницу, желающие что-то купить по акции. Тут помогают инструменты, такие как Apache JMeter и LoadRunner, где мы указываем, какие запросы с какой интенсивностью нужно отправлять, а затем запускаем и наблюдаем, как сервер себя ведет.

Теперь, после автоматизации всего этого, неплохо бы внедрить еще пару полезных вещей. Во-первых, встроить тесты в CI/CD pipeline, чтобы они автоматически запускались при добавлении нового функционала. Во-вторых, после проверки, составить отчет о тестировании, где указано, какие тесты прошли, что упало, на что нужно обратить внимание и так далее. Но писать их вручную тоже не хочется, поэтому мы также автоматизируем этот процесс. Для этого есть множество инструментов, таких как Allure Report. Он поддерживает множество языков и фреймворков, а также может создавать красочные графики и таблицы на основе результатов тестов для более ясного представления.

Сначала все нужно проверять вручную, удостовериться, что все работает, написать тест-кейсы и сценарии тестирования, а только потом приступать к автоматизации. Кроме того, некоторые вещи все равно может увидеть только человек. Например, компьютер пока может только сказать работает ли новая кнопка на сайте, но не в силах сказать удобно ли ей пользоваться. 

## Что такое IP - адерес и можно ли по нему что-то вычислить?

Давайте разберем что такое IP. Вот вам пример из реальной жизни. Если вам нужно отправить письмо, то на конверте нужно указать куда и от кого, его нужно отправить, приклеить марки, сходить на почту и постоять в очереди. Без этого ничего не выйдет. С IP адресом все также, это адрес компьютера, сервера или любой другой сетевой железки. Чтобы общаться с другими компьютерами или серверами, нужно чтобы у него был уникальный идентификатор. Чтобы понять куда нужно слать данные и как получить обратно. Например, мы хотим зайти на сайт, для этого нам нужно отправить письмо сайту и сказать что нам нужна его главная страница, сайт получит это письмо и вышлет нам страничку по адрему, указанному на конверте в поле отправителя.

Почему IP - адерес так странно выглядит? 

Компьютеры общаются нулями и единицами, которые называется битами и на самом деле этот адрес выглядит как строка из тридцати двух нулей. Представте себе комбинацию из нулей и единиц. Это двоичная система, потому что есть значение 1 и 0. Было принято перевести в десятичную систему и разбить это чисто на 4 части, поставив 3 точки. В итоге мы получили 4 числа от 0 до 255 с которыми гораздо проще работать. Это IPv4. Возможно вы видели IP - адереса с буквами - это адреса другой версии. Всего может существовать 4 294 967 296 адресов, что не хватит для всех устройст, особенно сейчас, когда адрес может быть даже у холодильника. Здесь мы уже используем число из 128 бит, который делим на 8 частей при помощи двоеточий и переводим их в шестнадцатиричную систему исчеслений, опять же для удобства. Принцип исчесления остается все тем же, но адресов больше 10 в 28 степени. 

В чем разница между статическим и динамическим адресом?

Статический остается одним и тем же, в то время как динамический назначается на определенное время, а потом меняется другим. Зачем это нужно? 
Если вы хотите попасть на сайт, вам нужно знать его адрес. Если он изменится, мы не сможем его нацти, для этого нужны статические адреса.
Но как посетителю сайта статический адрес не нужен, подойдет динамический, который вы напишете в конверте в поле отправителя. 

Также можно называть IP-адреса внутренними и внешними. Как мы уже знаем по IPV4 у нас ограниченное количество адресов, на всех не хватает. Но как нам дать возможноть всем выходить в интернет. Тут нам на помощь приходит технология NAT(Network address translation), а точнее ее настройка PAT(Port Address Translation), суть его в том, что много устройств могут выходить в интернет с одним и тем же адресом. Но как такое возможно, если мы сказали, что нельзя иметь два одинаковых адреса. Суть в том, что у вас есть внутренний адрес, который выдает провайдер, с которым вы находитесь внитри локальной сети, а есть внешний адрес, который провайдер вам дает для выхода в интернет. И несмотря на то, что у пользователей одинаковые адреса, их сожно отличить благодаря тому, что к адресу добавляется порт. Это уникальное значение после двоеточия, который присваивает провайдер 