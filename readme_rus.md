## Микросервисы 

Разбиваем приложение на несколько мини частей, мини программы, которые называются сервисами. Один сервис выполняет одну бизнес задачу.Получается конструктор, где каждый сервис - это отдельный блок. Падение одного сервиса может пройти относительно безболезненно для всего приложения. Каждый сервис имеет свой API по которому к нему можно будет обратиться, чтобы он сделал какую-нибудь задачу. Так сервисы могут общаться между собой делая HTTP или gRPC запросы. Такой способ называется синхронной коммуникации. Когда мы отправляем запрос и ждем что нам ответят с той стороны. 

Перед всеми сервисами обычно ставят API Gateway. Он нужен, чтобы пользователи делали запросы не на сами сервисы, а сначала на него, а он потом маршрутизировал их.  

Еще один вариант общения - это ассинхронная коммуникация, когда нам не нужно ждать ответа от сервиса. Тут сообщения шлются какому-то брокеру, типа RAbbitMQ или Kafka. Они попадают там в очередь, а затем принимаются сервисом, который вычитывает эту очередь и там уже выполняются нужные действия. При этом отправитель не ждет ответа, он идет работать дальше. 

Но как всегда есть и обратная сторона. Одних сложностей становится меньше, зато появляются другие. Так нам нужно теперь поднимать и настраивать каждый сервис отдельно, и связывать их друг с другом. Тут нужно подходить с умом к архитектуре. Особенно важно обращать внимание на консистентность таких данных - раз микросерсис обладает опеделенным набором данных в своей базе или схеме, то сделать join к другой таблице не получится - нужно собирать все по кусочкам как пазл уже на уровне логики приложения. К тому же здесь не обойтись без набора DevOps инструментов. Нам понадобится контейниризация, чтобы удобно, компактно и независимо разворачивать микросервисы. Стобы гибко управлять всем этим, хорошо бы уметь в оркестрацию. Чтобы удобно было deploy, стоит знать CI/CD pipe lines. Ну и в добавок настроить логирование и мониторинг, чтобы в случае чего быстро находить проблемные места.


## Автоматизация тестирования: программирование в QA

Почему так важно автоматизировать? Один раз ты можешь сделать что-то вручную, но если это нужно повторить в третий и десятый раз? Тут уже становится понятно, что нужно экономить свои силы, нервы и время. И вот тестирование - это одна из тех областей, где автоматизация сильно помогает.

Тестировщики проверяют новый функционал приложения, чтобы убедиться, что он работает так, как задумано. Также проверяют старый функционал, чтобы удостовериться, что новые полезные фичи не сломали ничего старого. Программы, создающие программы, - это и есть автоматизированное тестирование. Это процесс, когда разработчики пишут специальные программы или скрипты, называемые автотестами, чтобы указать компьютеру, какие действия нужно выполнить для проверки, что все работает правильно. При запуске они выполняют десятки или даже сотни различных сценариев взаимодействия с системой, а затем сообщают, какие прошли успешно, а какие - нет.

Что конкретно делают эти автотесты?

Можно, например, тестировать API - написать программу, которая будет отправлять запросы к серверу с разными параметрами и сверять ответы, полученные от сервера, с ожидаемыми результатами программы.

В общем, берем тесты, которые раньше выполняли вручную, например, заходим на страницу, нажимаем туда и сюда, и смотрим, что происходит. Теперь заставляем это делать бездушной машине, которая не жалуется и выполняет все намного быстрее. Такой вид тестирования называется end-to-end, когда мы полностью проходим путь пользователя от лица пользователя.

А как это работает? Давайте посмотрим на инструменты для автоматического тестирования. Начнем с Selenium. Это целая система инструментов, используемых для автоматизации браузеров. Нас интересует Selenium WebDriver - библиотека, позволяющая подключаться к браузеру и отправлять команды для выполнения различных действий, таких как нажатие на кнопку, заполнение поля и т. д. Полученные данные можно использовать как результат теста. Для этого нужно написать код, описывающий последовательность действий браузера и ожидаемый результат. Selenium поддерживает языки Java, Ruby, JavaScript и, конечно же, Python.

Популярными аналогами являются Puppeteer, Playwright, Cypress или Appium, которые выполняют аналогичные задачи, но для мобильных телефонов. Это хорошо работает с фреймворками, упрощающими работу с тестами, такими как Pytest для Python или JUnit для Java. В двух словах - это набор специальных функций для вашего языка программирования, которые позволяют легко и удобно писать и запускать тесты в приложениях.

Есть еще один вид тестирования - нагрузочное тестирование. Его суть заключается в оценке того, как система справляется с нагрузкой и не выходит из строя при внедрении в продакшн. Например, отправка на сервер огромного количества разных запросов одновременно, как если бы это были реальные пользователи в черную пятницу, желающие что-то купить по акции. Тут помогают инструменты, такие как Apache JMeter и LoadRunner, где мы указываем, какие запросы с какой интенсивностью нужно отправлять, а затем запускаем и наблюдаем, как сервер себя ведет.

Теперь, после автоматизации всего этого, неплохо бы внедрить еще пару полезных вещей. Во-первых, встроить тесты в CI/CD pipeline, чтобы они автоматически запускались при добавлении нового функционала. Во-вторых, после проверки, составить отчет о тестировании, где указано, какие тесты прошли, что упало, на что нужно обратить внимание и так далее. Но писать их вручную тоже не хочется, поэтому мы также автоматизируем этот процесс. Для этого есть множество инструментов, таких как Allure Report. Он поддерживает множество языков и фреймворков, а также может создавать красочные графики и таблицы на основе результатов тестов для более ясного представления.

Сначала все нужно проверять вручную, удостовериться, что все работает, написать тест-кейсы и сценарии тестирования, а только потом приступать к автоматизации. Кроме того, некоторые вещи все равно лучше о