## Микросервисы 

Разбиваем приложение на несколько мини частей, мини программы, которые называются сервисами. Один сервис выполняет одну бизнес задачу.Получается конструктор, где каждый сервис - это отдельный блок. Падение одного сервиса может пройти относительно безболезненно для всего приложения. Каждый сервис имеет свой API по которому к нему можно будет обратиться, чтобы он сделал какую-нибудь задачу. Так сервисы могут общаться между собой делая HTTP или gRPC запросы. Такой способ называется синхронной коммуникации. Когда мы отправляем запрос и ждем что нам ответят с той стороны. 

Перед всеми сервисами обычно ставят API Gateway. Он нужен, чтобы пользователи делали запросы не на сами сервисы, а сначала на него, а он потом маршрутизировал их.  

Еще один вариант общения - это ассинхронная коммуникация, когда нам не нужно ждать ответа от сервиса. Тут сообщения шлются какому-то брокеру, типа RAbbitMQ или Kafka. Они попадают там в очередь, а затем принимаются сервисом, который вычитывает эту очередь и там уже выполняются нужные действия. При этом отправитель не ждет ответа, он идет работать дальше. 

Но как всегда есть и обратная сторона. Одних сложностей становится меньше, зато появляются другие. Так нам нужно теперь поднимать и настраивать каждый сервис отдельно, и связывать их друг с другом. Тут нужно подходить с умом к архитектуре. Особенно важно обращать внимание на консистентность таких данных - раз микросерсис обладает опеделенным набором данных в своей базе или схеме, то сделать join к другой таблице не получится - нужно собирать все по кусочкам как пазл уже на уровне логики приложения. К тому же здесь не обойтись без набора DevOps инструментов. Нам понадобится контейниризация, чтобы удобно, компактно и независимо разворачивать микросервисы. Стобы гибко управлять всем этим, хорошо бы уметь в оркестрацию. Чтобы удобно было deploy, стоит знать CI/CD pipe lines. Ну и в добавок настроить логирование и мониторинг, чтобы в случае чего быстро находить проблемные места.


## Автоматизация тестирования: програмирование в QA

Почему так важно автоматизировать? Один раз ты можешь сделать что-то вручную, а если это надо повторить, третий и десятый раз? Тут уже становится понятно, что нужно экономить свои силы, нервы и время. И вот как раз тестирование - это одна из тех областей, где автоматизация сильно помогает. 

Тестировщики проверяют новый функционал приложения, что он работает так как задумано. А еще проверяют старый функционал, ведь нужно убедиться, что мы ничего не сломали нашими новыми полезными фичами. Программы, которые создают программы - это и есть автоматизированное тестирование. Процесс, когда разработчики пишут специальные программы или скрипты, их еще называют автотестами, которые говорят компьютеру какие действия надо выполнить, чтобы проверить, что все работает как следует. При запуске они прогоняют десятки или даже сотни различных сценариев взаимодействия с системой, которую мы проверяем и затем сообщают нам какие прошли успешно, а какие нет. 

А что конкретно эти автотесты делают?

Ну смотри лягушонок, можно тестировать API -то есть написать программу, которая будет делать запросы к твоему серверу с разными параметрами и сверять ответы какие пришли от сервера с тем какие их ожидает программа. 


Короче - берем наши тесты, которые раньше выполняли вручную. Типа зайти на эту страницу, нажать туда и сюда и посмотреть что будет, а потом все это повторить. А теперь заставляем это же делать бездушную машину, которая жаловаться не будет и выполнит все на порядок быстрее. Такой вид тестирования называется end-to-end, когда мы от лица юзера полностью проходим пользовательский путь. 

А как это работаем давай посмотрим на инструменты для автоматического тестирования. Начнем с Selenium. Это целая система инструментов, которая используется для автоматизации браузеров. 