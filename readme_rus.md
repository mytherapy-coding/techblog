## Микросервисы 

Разбиваем приложение на несколько мини частей, мини программы, которые называются сервисами. Один сервис выполняет одну бизнес задачу.Получается конструктор, где каждый сервис - это отдельный блок. Падение одного сервиса может пройти относительно безболезненно для всего приложения. Каждый сервис имеет свой API по которому к нему можно будет обратиться, чтобы он сделал какую-нибудь задачу. Так сервисы могут общаться между собой делая HTTP или gRPC запросы. Такой способ называется синхронной коммуникации. Когда мы отправляем запрос и ждем что нам ответят с той стороны. 

Перед всеми сервисами обычно ставят API Gateway. Он нужен, чтобы пользователи делали запросы не на сами сервисы, а сначала на него, а он потом маршрутизировал их.  

Еще один вариант общения - это ассинхронная коммуникация, когда нам не нужно ждать ответа от сервиса. Тут сообщения шлются какому-то брокеру, типа RAbbitMQ или Kafka. Они попадают там в очередь, а затем принимаются сервисом, который вычитывает эту очередь и там уже выполняются нужные действия. При этом отправитель не ждет ответа, он идет работать дальше. 

Но как всегда есть и обратная сторона. Одних сложностей становится меньше, зато появляются другие. Так нам нужно теперь поднимать и настраивать каждый сервис отдельно, и связывать их друг с другом. Тут нужно подходить с умом к архитектуре. Особенно важно обращать внимание на консистентность таких данных - раз микросерсис обладает опеделенным набором данных в своей базе или схеме, то сделать join к другой таблице не получится - нужно собирать все по кусочкам как пазл уже на уровне логики приложения. К тому же здесь не обойтись без набора DevOps инструментов. Нам понадобится контейниризация, чтобы удобно, компактно и независимо разворачивать микросервисы. Стобы гибко управлять всем этим, хорошо бы уметь в оркестрацию. Чтобы удобно было deploy, стоит знать CI/CD pipe lines. Ну и в добавок настроить логирование и мониторинг, чтобы в случае чего быстро находить проблемные места.