## Микросервисы 

Разбиваем приложение на несколько мини частей, мини программы, которые называются сервисами. Один сервис выполняет одну бизнес задачу.Получается конструктор, где каждый сервис - это отдельный блок. Падение одного сервиса может пройти относительно безболезненно для всего приложения. Каждый сервис имеет свой API по которому к нему можно будет обратиться, чтобы он сделал какую-нибудь задачу. Так сервисы могут общаться между собой делая HTTP или gRPC запросы. Такой способ называется синхронной коммуникации. Когда мы отправляем запрос и ждем что нам ответят с той стороны. 

Перед всеми сервисами обычно ставят API Gateway. Он нужен, чтобы пользователи делали запросы не на сами сервисы, а сначала на него, а он потом маршрутизировал их.  

Еще один вариант общения - это ассинхронная коммуникация, когда нам не нужно ждать ответа от сервиса. Тут сообщения шлются какому-то брокеру, типа RAbbitMQ или Kafka. Они попадают там в очередь, а затем принимаются сервисом, который вычитывает эту очередь и там уже выполняются нужные действия. При этом отправитель не ждет ответа, он идет работать дальше. 

Но как всегда есть и обратная сторона. Одних сложностей становится меньше, зато появляются другие. Так нам нужно теперь поднимать и настраивать каждый сервис отдельно, и связывать их друг с другом. Тут нужно подходить с умом к архитектуре. Особенно важно обращать внимание на консистентность таких данных - раз микросерсис обладает опеделенным набором данных в своей базе или схеме, то сделать join к другой таблице не получится - нужно собирать все по кусочкам как пазл уже на уровне логики приложения. К тому же здесь не обойтись без набора DevOps инструментов. Нам понадобится контейниризация, чтобы удобно, компактно и независимо разворачивать микросервисы. Стобы гибко управлять всем этим, хорошо бы уметь в оркестрацию. Чтобы удобно было deploy, стоит знать CI/CD pipe lines. Ну и в добавок настроить логирование и мониторинг, чтобы в случае чего быстро находить проблемные места.


## Автоматизация тестирования: программирование в QA

Почему так важно автоматизировать? Один раз ты можешь сделать что-то вручную, но если это нужно повторить в третий и десятый раз? Тут уже становится понятно, что нужно экономить свои силы, нервы и время. И вот тестирование - это одна из тех областей, где автоматизация сильно помогает.

Тестировщики проверяют новый функционал приложения, чтобы убедиться, что он работает так, как задумано. Также проверяют старый функционал, чтобы удостовериться, что новые полезные фичи не сломали ничего старого. Программы, создающие программы, - это и есть автоматизированное тестирование. Это процесс, когда разработчики пишут специальные программы или скрипты, называемые автотестами, чтобы указать компьютеру, какие действия нужно выполнить для проверки, что все работает правильно. При запуске они выполняют десятки или даже сотни различных сценариев взаимодействия с системой, а затем сообщают, какие прошли успешно, а какие - нет.

Что конкретно делают эти автотесты?

Можно, например, тестировать API - написать программу, которая будет отправлять запросы к серверу с разными параметрами и сверять ответы, полученные от сервера, с ожидаемыми результатами программы.

В общем, берем тесты, которые раньше выполняли вручную, например, заходим на страницу, нажимаем туда и сюда, и смотрим, что происходит. Теперь заставляем это делать бездушной машине, которая не жалуется и выполняет все намного быстрее. Такой вид тестирования называется end-to-end, когда мы полностью проходим путь пользователя от лица пользователя.

А как это работает? Давайте посмотрим на инструменты для автоматического тестирования. Начнем с Selenium. Это целая система инструментов, используемых для автоматизации браузеров. Нас интересует Selenium WebDriver - библиотека, позволяющая подключаться к браузеру и отправлять команды для выполнения различных действий, таких как нажатие на кнопку, заполнение поля и т. д. Полученные данные можно использовать как результат теста. Для этого нужно написать код, описывающий последовательность действий браузера и ожидаемый результат. Selenium поддерживает языки Java, Ruby, JavaScript и, конечно же, Python.

Популярными аналогами являются Puppeteer, Playwright, Cypress или Appium, которые выполняют аналогичные задачи, но для мобильных телефонов. Это хорошо работает с фреймворками, упрощающими работу с тестами, такими как Pytest для Python или JUnit для Java. В двух словах - это набор специальных функций для вашего языка программирования, которые позволяют легко и удобно писать и запускать тесты в приложениях.

Есть еще один вид тестирования - нагрузочное тестирование. Его суть заключается в оценке того, как система справляется с нагрузкой и не выходит из строя при внедрении в продакшн. Например, отправка на сервер огромного количества разных запросов одновременно, как если бы это были реальные пользователи в черную пятницу, желающие что-то купить по акции. Тут помогают инструменты, такие как Apache JMeter и LoadRunner, где мы указываем, какие запросы с какой интенсивностью нужно отправлять, а затем запускаем и наблюдаем, как сервер себя ведет.

Теперь, после автоматизации всего этого, неплохо бы внедрить еще пару полезных вещей. Во-первых, встроить тесты в CI/CD pipeline, чтобы они автоматически запускались при добавлении нового функционала. Во-вторых, после проверки, составить отчет о тестировании, где указано, какие тесты прошли, что упало, на что нужно обратить внимание и так далее. Но писать их вручную тоже не хочется, поэтому мы также автоматизируем этот процесс. Для этого есть множество инструментов, таких как Allure Report. Он поддерживает множество языков и фреймворков, а также может создавать красочные графики и таблицы на основе результатов тестов для более ясного представления.

Сначала все нужно проверять вручную, удостовериться, что все работает, написать тест-кейсы и сценарии тестирования, а только потом приступать к автоматизации. Кроме того, некоторые вещи все равно может увидеть только человек. Например, компьютер пока может только сказать работает ли новая кнопка на сайте, но не в силах сказать удобно ли ей пользоваться. 

## Что такое IP-адрес и можно ли по нему что-то вычислить?

Давайте разберем, что такое IP-адрес. Вот вам пример из реальной жизни: если вам нужно отправить письмо, то на конверте нужно указать куда и от кого, его нужно отправить, приклеить марки, сходить на почту и постоять в очереди. Без этого ничего не выйдет. С IP-адресом все также – это адрес компьютера, сервера или любой другой сетевой железки. Чтобы общаться с другими компьютерами или серверами, нужно, чтобы у него был уникальный идентификатор. Это необходимо для того, чтобы понять, куда нужно слать данные и как получить их в ответ. Например, если мы хотим зайти на сайт, нам нужно отправить запрос на сервер этого сайта, указав, что нам нужна его главная страница. Сайт получит этот запрос и отправит нам страницу по адресу, указанному в нашем запросе.

Почему IP-адрес выглядит так странно?

Компьютеры общаются нулями и единицами, называемыми битами. На самом деле IP-адрес выглядит как строка из тридцати двух нулей, представляющих двоичную систему. Для удобства работы с этими числами, их принято перевести в десятичную систему и разбить на 4 части, поставив 3 точки. Это дает нам формат IPv4, который состоит из 4 чисел от 0 до 255. В настоящее время также существует новая версия IP-адреса, обозначаемая с использованием букв – это IPv6. IPv6 использует 128 бит и представляет собой комбинацию из 8 групп символов, разделенных двоеточиями, что обеспечивает гораздо большее количество уникальных адресов – более 10 в 28 степени.

В чем разница между статическим и динамическим IP-адресом?

Статический IP-адрес остается неизменным, в то время как динамический назначается на определенный период и может меняться. Статические адреса полезны, если вам нужно постоянно знать, где находится определенное устройство в сети. Динамические адреса удобны для пользователей, так как они могут меняться, и для их поиска в сети достаточно временного присвоенного адреса.

Также можно выделить внутренние и внешние IP-адреса. Поскольку IPv4 имеет ограниченное количество адресов, используется технология Network Address Translation (NAT), а именно ее настройка – Port Address Translation (PAT). PAT позволяет множеству устройств внутри локальной сети выходить в интернет с одним и тем же внешним адресом. Это достигается добавлением уникального порта к внешнему адресу, что обеспечивает отличие между устройствами и повышает уровень безопасности.

Что касается возможности вычисления по IP-адресу?

Вычислить конкретное устройство по его внешнему IP-адресу сложно, так как этот адрес является общим для тысяч других компьютеров. Провайдер может сопоставить внешний адрес с внутренним, но для конкретного вычисления требуется дополнительная информация, которую может предоставить только провайдер.

## HTTP или HTTPS - как это работает и в чем разница?

HTTP:// расшифровывается как протокол передачи гипертекста (Hypertext Transfer Protocol). Зачем эти префиксы греческого происхождения? Термин "гипертекст" обозначает систему текстовых страниц, которые имеют различные сноски и ссылаются друг на друга. Самый древний пример литературного гипертекста - Библия. Сейчас гипертекст ассоциируется с интернетом, и любая веб-страница в нем - это гипертекст. Стоит нажать на какую-нибудь картинку, как вас сразу же перебросит в другое место. Это называется гиперссылкой. Так вот, HTTP передает гипертекст с гиперссылками, представляя собой путь до другого файла в интернете. Это делается с помощью установления TCP сессии по порту 80.

С помощью HTTP вы получаете страницу с видео, а сама страница написана на языке разметки гипертекста HTML (Hypertext Markup Language). HTTP - это клиент-серверный протокол. Это означает, что у вас есть клиент (в данном случае, вы), который хочет получить какие-то данные (в данном случае, видео), и сервер, где хранятся эти данные. Увидев видео на YouTube, например, и нажав на него, вы отправляете HTTP запрос на сервер YouTube и в ответ получаете HTML страницу с этим видео. Также на нее можно попасть, зная ее адрес или URL (Uniform Resource Locator), что переводится как унифицированный указатель ресурса.

HTTP состоит из стартовой строки, заголовка и тела сообщения. В стартовой строке указывается URL, то есть адрес, куда послать запрос, и метод запроса. Например, запрашивая видео, вы отправляете запрос методом GET. Еще существуют методы POST, PUT, HEAD, DELETE и другие. Стартовая строка ответа от сервера отличается от запроса: в ней передается трехзначный код состояния обработки вашего запроса. Например, если все прошло успешно, вернется код 200 OK, а если сервер ничего не смог найти по вашему запросу, вы получите знаменитый код 404 Not Found. Всего существует 5 типов кодов:

1xx - информирование о процессе передачи запроса.
2xx - информирование об успешной передаче.
3xx - информирование о перенаправлении.
4xx - ошибки клиента, означающие, что либо запрашиваемое не найдено, либо запрос сделан неправильно, либо доступ запрещен.
5xx - ошибки сервера, означающие, что серверу сейчас тяжело.

Идем дальше. Заголовки - это параметры, которые определяют запрос или описывают тело сообщения. Например, это может быть информация об используемом браузере, языке, авторизации и так далее. В конце идет тело - это данные, которые мы передаем в запросе (например, текст комментария) или ответ, который мы получаем от сервера (страница с видео).

Все эти данные протокол передает в открытом виде как обычный текст. Это небезопасно. Именно поэтому появилось расширение протокола под названием HTTPS, где "S" означает secure (безопасный).

HTTPS шифрует все данные перед передачей и делает невозможным их чтение при перехвате. Шифрование обеспечивают механизмы SSL и TLS. SSL (Secure Socket Layer) работает так: когда мы подключаемся к сайту, использующему SSL, сначала просим сайт идентифицировать себя. В ответ он присылает нам копию SSL сертификата, доказывая, что с ним общение безопасно. Браузер проверяет его и, если все в порядке, отвечает сайту, что ему можно доверять, и начинается обмен шифрованными данными. Как же браузер узнает, что сертификат в порядке? Дело в том, что сертификаты выдают центры сертификации, и не кому попало они не выдаются. Они проверяют пользователя и его права на ресурс, чтобы пользователь был уверен, что сайт настоящий. Также эти центры сертификации подтверждают браузеру, что присланный сертификат действителен.

Второй протокол - TLS (Transport Layer Security) является новой версией SSL. Он также проверяет подлинность сервера и шифрует данные. В настоящее время применяются TLS 1.2 и 1.3.

Поисковики занижают сайты без HTTPS в рейтинге поисковой выдачи, а Google даже угрожает прекратить взаимодействие с такими ресурсами.

## DNS сервер - что это и как работает?

DNS (Domain Name System)

Лучший пример из жизни - контакты в твоем смартфоне. Так, например, за именем ALENA скрываются реальные цифры номера телефона. Однако когда мы ищем контакт в поиск, мы вводим не номер телефона, а имя. Примерно это же и делает DNS сервер - он упрощает нашу жизнь.

Сначала ваше устройство проверит кэш браузера или операционной системы. Ведь если до этого вы посещали сайт, то запись о нем останется локально в кэше, чтобы в последующие разы не тратить время на поиск.

Если сайт оказался новым, тогда отправляется запрос resolver (распознающему) DNS серверу. Обычно этот сервер находится у провайдера, но мы можем его поменять, используя, например, четыре восьмерки (8.8.8.8). При поиске, если не находит адреса, резолвер шлет запрос к корневому root server. Это сервер, который находится на самом верху DNS. Root server не один, их множество, чтобы не искать адрес в куче, а уйти в нужную ветку. Дальше нам нужно обратиться к нужному серверу верхнего уровня или TLD (top level) domain серверу. Домены верхнего уровня - это то, что идет после точки com org net. Кстати, существуют Generic Top Level Domain (gTLD), которые не привязаны к стране, например, .edu, .com, .ai (организации, связанные с искусственным интеллектом), а также есть Country Code Top Level Domain (ccTLD), которые привязаны к стране: .ru, .us, .uk.

Дальше резолвер отправляет на уровень ниже - к серверу авторитетных имен (Authoritative nameserver), который нам уже скажет нужный нам адрес.

Затем резолвер записывает адрес в кэш, чтобы снова не проходить по той же цепочке.